/**
 * Created by shaunwest on 8/22/15.
 */

import React, { Component } from 'react';
import { connect } from 'react-redux';
import LayerToolbar from '../toolbars/layer-toolbar.js';
import Layer from './layer.js';
import InputLayer from './input-layer.js';
import * as Tools from '../../constants/tools.js';
import { addTiles, fillTileSelection, updateTiles,
  moveTileSelection, fillContiguousTiles } from '../../lib/layers.js';
import Viewport from '../../lib/viewport.js';

class Layers extends Component {
  constructor(props) {
    super(props);

    // FIXME: viewport size should be in the datastore
    // But maybe not viewport position?
    this.state = {
      viewport: Viewport(0, 0, 400, 256)
    };
  }

  triggerSelectorAction(layout, layerWidth, position, lastPosition, selection) {
    const { filters } = this.props,
      tileId = filters.get('selectedTileIndex');

    switch (filters.get('selectedToolId')) {
      case Tools.ERASER:
        fillTileSelection(layout, layerWidth, undefined, selection);
        return;
      case Tools.FILL:
        fillTileSelection(layout, layerWidth, tileId, selection);
        return;
      case Tools.FILL_EMPTY:
        fillTileSelection(layout, layerWidth, tileId, selection, true);
        return;
      case Tools.TILE_BRUSH:
        addTiles(layout, layerWidth, lastPosition, position, tileId, selection);
        return;
      case Tools.FILL_CONTIGUOUS:
        fillContiguousTiles(layout, layerWidth, position, tileId, true, selection);
        return;
      case Tools.FILL_CONTIGUOUS_EMPTY:
        fillContiguousTiles(layout, layerWidth, position, tileId, false, selection);
        return;
      case Tools.GRABBER:
        moveTileSelection(layout, layerWidth, position, selection);
        return; 
    }
  }

  triggerPointerAction(layout, layerWidth, position, lastPosition) {
    const { filters } = this.props,
      tileId = filters.get('selectedTileIndex');

    switch (filters.get('selectedToolId')) {
      case Tools.TILE_BRUSH:
        addTiles(layout, layerWidth, lastPosition, position, tileId);
        return;
      case Tools.ERASER:
        addTiles(layout, layerWidth, lastPosition, position);
        return;
      case Tools.FILL:
        fillTileSelection(layout, layerWidth, tileId);
        return;
      case Tools.FILL_EMPTY:
        fillTileSelection(layout, layerWidth, tileId, true);
        return;
      case Tools.FILL_CONTIGUOUS:
        fillContiguousTiles(layout, layerWidth, position, tileId, true);
        return;
      case Tools.FILL_CONTIGUOUS_EMPTY:
        fillContiguousTiles(layout, layerWidth, position, tileId);
        return;
    }
  }

  syncLayout(layout) {
    const { filters } = this.props;

    const activeLayerId = filters.get('activeLayerId');
    dispatch(updateTiles(layout, activeLayerId));
  }

  render() {
    const { layers, filters } = this.props;
    const activeLayer = layers.get(filters.get('activeLayerId'));
    const viewport = this.state.viewport;

    return (
      <div>
        <LayerToolbar activeLayer={ activeLayer } />
        <ul className="layersContainer">
        {
          layers
            .map(layer => {
              const layerId = layer.get('id');
              return (
                <li className="layer" key={ layerId }>
                  <Layer
                    layerId={ layerId }
                    viewport={ viewport }
                    renderLoop={ this.props.renderLoop }
                  />
                </li>
              );
            })
            .valueSeq()
        }
          <InputLayer
            ref="inputLayer"
            viewport={ viewport }
            selectedToolId={ filters.get('selectedToolId') }
            renderLoop={ this.props.renderLoop }
            onSelectorAction={ this.triggerSelectorAction.bind(this) }
            onPointerAction={ this.triggerPointerAction.bind(this) }
          />
        </ul>
      </div>
    );
  } 
}

function select(state) {
  return { 
    layers: state.get('layers'),
    filters: state.get('filters')
  };
}

export default connect(select)(Layers);
